# Module for guiding Slit/Order tracing
from __future__ import absolute_import, division, print_function

import inspect
import numpy as np
import os
from subprocess import Popen

from scipy import ndimage

from importlib import reload

from astropy.io import fits

from linetools import utils as ltu

from pypeit import msgs
from pypeit import debugger
from pypeit.core import parse, trace_slits, extract, pixels
from pypeit import utils
from pypeit import masterframe
from pypeit import ginga
from pypeit.spectrographs import util

from pypeit.par import pypeitpar
from pypeit.par.util import parset_to_dict


class TraceSlits(masterframe.MasterFrame):
    """Class to guide slit/order tracing

    Parameters
    ----------
    mstrace : ndarray
      Trace image
    spectrograph : Spectrograph
    binbpx : ndarray, optional
      Bad pixel mask
      If not provided, a dummy array with no masking is generated
    settings : dict, optional
      Settings for trace slits
    det : int, optional
      Detector number
    ednum : int, optional
      Edge number used for indexing
    redux_path : str, optional
      Used for QA output

    Attributes
    ----------
    frametype : str
      Hard-coded to 'trace'
    lcen : ndarray [nrow, nslit]
      Left edges, in physical space
    rcen : ndarray [nrow, nslit]
      Right edges, in physical space
    lordpix : ndarray [nrow, nslit]
      Left edges, in pixel space
    rordpix : ndarray [nrow, nslit]
      Right edges, in pixel space
    slitpix : ndarray (int)
      Image specifiying which pixels are in which slit
    slitcen : ndarray [nrow, nslit]
      Pixel values down the center of the slit
    pixwid : ndarray [nrow, nslit]
      Width of slit in pixels (integer)
    extrapord : ndarray
      ??

    edgearr : ndarray
      Edge image
      -200000, 200000 indexing -- ??
      -100000, 100000 indexing -- Edges defined but additional work in progress
      -1, 1 indexing -- Edges finalized
    tc_dict : dict, optional
      Dict guiding multi-slit work
      [left,right][xval][edge]
    steps : list
      List of the processing steps performed
    siglev : ndarray
      Sobolev filtered image of mstrace
      Used to find images and used for tracing
    binarr : ndarray
      Uniform filter version of mstrace
      Generated by make_binarr()
    user_set : bool
      Did the user set the slit?  If so, most of the automated algorithms are skipped
    lmin : int
      Lowest left edge, edgearr value
    lmax : int
      Highest left edge, edgearr value
    rmin : int
      Lowest right edge, edgearr value
    rmax : int
      Highest right edge, edgearr value
    lcnt : int
      Number of left edges
    rcnt : int
      Number of right edges
    """

    # Frametype is a class attribute
    frametype = 'trace'

    def __init__(self, mstrace, spectrograph,
                 binning=None,
                 par=None, det=1, master_key=None, master_dir=None,
                 redux_path=None,
                 reuse_masters=False, binbpx=None, ednum=100000):

        # MasterFrame
        masterframe.MasterFrame.__init__(self, self.frametype, master_key, master_dir=master_dir,
                                         reuse_masters=reuse_masters)

        # TODO -- Remove pixlocn as a required item

        # TODO: (KBW) Why was setup='' in this argument list and
        # setup=None in all the others?  Is it because of the
        # from_master_files() classmethod below?  Changed it to match
        # the rest of the MasterFrame children.


        # Required parameters (but can be None)
        self.mstrace = mstrace
#        self.pixlocn = pixlocn
        self.spectrograph = spectrograph
        self.binning = binning

        # Set the parameters, using the defaults if none are provided
        self.par = pypeitpar.TraceSlitsPar() if par is None else par

        # Optional parameters
        self.redux_path = redux_path
        self.det = det
        self.ednum = ednum
        if binbpx is None: # Bad pixel array
            self.binbpx = np.zeros_like(mstrace)
            self.input_binbpx = False # For writing
        else:
            self.binbpx = binbpx
            self.input_binbpx = True

        # Main outputs
        self.lcen = None     # narray
        self.rcen = None     # narray
        self.tc_dict = None  # dict
        self.edgearr = None  # ndarray
        self.siglev = None   # ndarray
        self.steps = []
        self.extrapord = None
        self.slitcen = None
        self.pixwid = None
        self.lordpix = None
        self.rordpix = None
        self.slitpix = None
        self.lcen_tweak = None   # Place holder for tweaked slit boundaries from flat fielding routine.
        self.rcen_tweak = None

        # Key Internals
        if mstrace is not None:
            self.binarr = self._make_binarr()
        self.user_set = None
        self.lmin = None
        self.lmax = None
        self.rmin = None
        self.rmax = None
        self.lcnt = None
        self.rcnt = None
        self.lcoeff = None
        # Fitting
        self.lnmbrarr = None
        self.ldiffarr = None
        self.lwghtarr = None
        self.rcoeff = None
        self.rnmbrarr = None
        self.rdiffarr = None
        self.rwghtarr = None

    # TODO I think this routine should be deprecated.
    @classmethod
    def from_master_files(cls, root, load_pix_obj=False, par=None):
        """
        Instantiate from the primary MasterFrame outputs of the class

        Parameters
        ----------
        root : str
          Path + root name for the TraceSlits objects (FITS, JSON)

        Returns
        -------
        slf

        """
        fits_dict, ts_dict = load_traceslit_files(root)
        msgs.info("Loading Slits from {:s}".format(root + '.fits.gz'))

        # Deal with parameters
        if par is None:
            if ts_dict is not None:
                par = pypeitpar.TraceSlitsPar.from_dict(ts_dict['settings'])
            else:
                par = pypeitpar.TraceSlitsPar()

        # Deal with the bad pixel image
        if 'BINBPX' in fits_dict.keys():
            binbpx = fits_dict['BINBPX'].astype(float)
            msgs.info("Loading BPM from {:s}".format(root+'.fits.gz'))
        else:
            binbpx = None

        # Instantiate from file
        spectrograph = util.load_spectrograph(ts_dict['spectrograph'])
        slf = cls(fits_dict['MSTRACE'], spectrograph, binbpx=binbpx, par=par)

        # Fill in a bit more (Attributes)
        slf.steps = ts_dict['steps']
        slf.binning = ts_dict['binning']

        # Others
        for key in ['LCEN', 'RCEN', 'EDGEARR', 'SIGLEV']:
            if key in fits_dict.keys():
                setattr(slf, key.lower(), fits_dict[key])
        # dict
        slf.tc_dict = ts_dict['tc_dict']

        # Load the pixel objects?
        if load_pix_obj:
            slf._make_pixel_arrays()

        # Return
        return slf

    @property
    def nslit(self):
        if self.lcen is None:
            return 0
        else:
            return self.lcen.shape[1]

    def _edgearr_from_binarr(self):
        """
        Generate the first edgearr from the Sobolev produced siglev image
        Wrapper to trace_slits.edgearr_from_binarr

        Returns
        -------
        self.edgearr : ndarray (internal)
        self.siglev : ndarray (internal)

        """
        self.siglev, self.edgearr \
                = trace_slits.edgearr_from_binarr(self.binarr, self.binbpx,
                                                   medrep=self.par['medrep'],
                                                   sobel_mode=self.par['sobel_mode'],
                                                   sigdetect=self.par['sigdetect'])
                                                   #number_slits=self.par['number'])
        # Step
        self.steps.append(inspect.stack()[0][3])

    def _edgearr_single_slit(self):
        """
        Generate the first edgearr from a user-supplied single slit
        Note this is different from add_user_slits (which is handled below)

        Wrapper to trace_slits.edgearr_from_user

        Returns
        -------
        self.edgearr : ndarray (internal)
        self.siglev : ndarray (internal)

        """
        #  This trace slits single option is likely to be deprecated
        iledge, iredge = (self.det-1)*2, (self.det-1)*2+1
        self.edgearr = trace_slits.edgearr_from_user(self.mstrace.shape,
                                                      self.par['single'][iledge],
                                                      self.par['single'][iredge], self.det)
        self.siglev = None
        # Step
        self.steps.append(inspect.stack()[0][3])

    def _add_left_right(self):
        """
        Add left/right edges to edgearr

        Wrapper to trace_slits.edgearr_add_left_right()
        If 0 is returned for both counts, this detector will be skipped

        Returns
        -------
        any_slits: bool

        self.edgearr : ndarray (internal)
        self.lcnt : int (internal)
        self.rcnt : int (internal)


        """
        self.edgearr, self.lcnt, self.rcnt = trace_slits.edgearr_add_left_right(
            self.edgearr, self.binarr, self.binbpx, self.lcnt, self.rcnt, self.ednum)
        # Check on return
        if (self.lcnt == 0) and (self.rcnt == 0):
            any_slits = False
        else:
            any_slits = True

        # Step
        self.steps.append(inspect.stack()[0][3])
        return any_slits

    def add_user_slits(self, user_slits, run_to_finish=False, orig=False):
        """
        Add a user-defined slit

        Wrapper to trace_slits.add_user_edges()

        Parameters
        ----------
        user_slits : list
        run_to_finish : bool (optional)
          Perform the additional steps to complete TraceSlit operation

        Returns
        -------
        self.edgearr : ndarray (internal)

        """
        # Reset (if needed) -- For running after PyepIt took a first pass
        #self.reset_edgearr_ednum()
        # Add user input slits
        if orig:
            self.edgearr = trace_slits.orig_add_user_edges(self.edgearr, self.siglev, self.tc_dict, user_slits)
        else:
            trace_slits.add_user_edges(self.tc_dict, user_slits)
        '''
        # Finish
        if run_to_finish:
            self._set_lrminx()
            self._fit_edges('left')
            self._fit_edges('right')
            self._synchronize()
            self._pca()
            self._trim_slits(plate_scale = plate_scale)
        '''
        # Step
        self.steps.append(inspect.stack()[0][3])

    def _assign_edges(self):
        """
        Assign slit edges by analyzing edgearr
        Single slits are handled trivially

        Wrapper to trace_slits.assign_slits()

        Returns
        -------
        self.edgearr : ndarray (internal)

        """

        # Assign left edges
        msgs.info("Assigning left slit edges")
        if self.lcnt == 1:
            self.edgearr[np.where(self.edgearr <= -2*self.ednum)] = -self.ednum
        else:
            trace_slits.assign_slits(self.binarr, self.edgearr, lor=-1,
                                      function=self.par['function'],
                                      polyorder=self.par['polyorder'])
        # Assign right edges
        msgs.info("Assigning right slit edges")
        if self.rcnt == 1:
            self.edgearr[np.where(self.edgearr >= 2*self.ednum)] = self.ednum
        else:
            trace_slits.assign_slits(self.binarr, self.edgearr, lor=+1,
                                      function=self.par['function'],
                                      polyorder=self.par['polyorder'])
        # Steps
        self.steps.append(inspect.stack()[0][3])

    def _chk_for_longslit(self, fwhm=3.):
        """
        Are we done?, i.e. we have a simple longslit, i.e. one left and one right

        Returns
        -------

        """
        orig = False
        if orig:
            if (self.lmax+1-self.lmin == 1) and (self.rmax+1-self.rmin == 1):
                plxbin = self.pixlocn[:, :, 0].copy()
                minvf, maxvf = plxbin[0, 0], plxbin[-1, 0]
                # Just a single order has been identified (i.e. probably longslit)
                msgs.info("Only one slit was identified. Should be a longslit.")
                xint = self.pixlocn[:, 0, 0]
                # Finish
                self.lcen = np.zeros((self.mstrace.shape[0], 1))
                self.rcen = np.zeros((self.mstrace.shape[0], 1))
                self.lcen[:, 0] = utils.func_val(self.lcoeff[:, 0], xint, self.par['function'],
                                                   minx=minvf, maxx=maxvf)
                self.rcen[:, 0] = utils.func_val(self.rcoeff[:, 0], xint, self.par['function'],
                                                   minx=minvf, maxx=maxvf)
                return True
            else:
                return False
        else:
            if (len(self.tc_dict['left']['xval']) == 1) and (
                    len(self.tc_dict['right']['xval']) == 1):
                # fweight the trace crude
                for key,sign in zip(['left','right'], [1., -1.]):
                    trace_crutch = self.tc_dict[key]['xset']
                    trace_fweight, _, _, _ = extract.iter_tracefit(np.fmax(sign*self.siglev, 0.0),
                                                          trace_crutch, self.par['polyorder'],
                                                          fwhm=3.0*fwhm, niter=9)
                    trace_gweight, _, _, _ = extract.iter_tracefit(np.fmax(sign*self.siglev, 0.0),
                                                          trace_fweight, self.par['polyorder'],
                                                          fwhm=fwhm,gweight=True, niter=6)
                    self.tc_dict[key]['traces'] = trace_gweight
                return True
            else:
                return False


    def _fill_tslits_dict(self):
        """
        Build a simple dictionary holding the key trace bits and pieces that PyepIt wants

        Returns
        -------
        self.trace_slits_dict : dict

        """
        self.tslits_dict = {}
        # Have the slit boundaries been tweaked? If so use the tweaked boundaries
        if self.lcen_tweak is not None:
            self.tslits_dict['slit_left'] = self.lcen_tweak
            self.tslits_dict['slit_righ'] = self.rcen_tweak
        else:
            self.tslits_dict['slit_left'] = self.lcen
            self.tslits_dict['slit_righ'] = self.rcen


        # Fill in the rest of the keys that were generated by make_pixel_arrays from the slit boundaries. This was
        # done with tweaked boundaries if they exist.
        # TODO I believe some of these quantities are deprecated.
        #for key in ['slitcen', 'pixwid', 'lordpix','rordpix', 'extrapord']:
        #    self.tslits_dict[key] = getattr(self, key)
        # add in the image size and some stuff to create the slitmask
        self.tslits_dict['slitcen'] = self.slitcen
        self.tslits_dict['nspec'] = self.mstrace.shape[0]
        self.tslits_dict['nspat'] = self.mstrace.shape[1]
        self.tslits_dict['nslits'] = self.lcen.shape[1]
        self.tslits_dict['pad'] = self.par['pad']
        binspatial, binspectral = parse.parse_binning(self.binning)
        self.tslits_dict['binspectral'] = binspectral
        self.tslits_dict['binspatial'] = binspatial
        self.tslits_dict['spectrograph'] = self.spectrograph.spectrograph
        self.tslits_dict['spec_min'], self.tslits_dict['spec_max'] = \
            self.spectrograph.slit_minmax(self.tslits_dict['nslits'], binspectral = binspectral)


        return self.tslits_dict

    def _final_left_right(self):
        """
        Last check on left/right edges

        Wrapper to trace_slits.edgearr_final_left_right()

        Returns
        -------
        self.edgearr : ndarray (internal)
        self.lcnt : int (internal)
        self.rcnt : int (internal)

        """
        # Final left/right edgearr fussing (as needed)
        self.edgearr, self.lcnt, self.rcnt = trace_slits.edgearr_final_left_right(
            self.edgearr, self.ednum, self.siglev)
        # Steps
        self.steps.append(inspect.stack()[0][3])

    # JFH This routine is deprecated
    # def _fit_edges(self, side):
    #     """
    #     Fit the edges with (left or right)
    #
    #     Wrapper to trace_slits.fit_edges()
    #
    #     Parameters
    #     ----------
    #     side : str
    #       'left' or 'right'
    #
    #     Returns
    #     -------
    #     self.lcoeff
    #     self.lnmbrarr
    #     self.ldiffarr
    #     self.lwghtarr
    #     or
    #     self.rcoeff
    #     self.rnmbrarr
    #     self.rdiffarr
    #     self.rwghtarr
    #
    #     """
    #     # Setup for fitting
    #     plxbin = self.pixlocn[:, :, 0].copy()
    #     plybin = self.pixlocn[:, :, 1].copy()
    #
    #     # Fit
    #     if side == 'left':
    #         self.lcoeff, self.lnmbrarr, self.ldiffarr, self.lwghtarr \
    #                 = trace_slits.fit_edges(self.edgearr, self.lmin, self.lmax, plxbin, plybin,
    #                                          left=True, polyorder=self.par['polyorder'],
    #                                          function=self.par['function'])
    #     else:
    #         self.rcoeff, self.rnmbrarr, self.rdiffarr, self.rwghtarr \
    #                 = trace_slits.fit_edges(self.edgearr, self.rmin, self.rmax, plxbin, plybin,
    #                                          left=False, polyorder=self.par['polyorder'],
    #                                          function=self.par['function'])
    #
    #     # Steps
    #     self.steps.append(inspect.stack()[0][3]+'_{:s}'.format(side))

    def _make_pixel_arrays(self):
        """
        Generate pixel arrays
        Primarily for later stages of PyepIt

        Returns
        -------
        self.slitcen
        self.pixwid
        self.lordpix
        self.rordpix
        self.slitpix

        """
        if self.lcen_tweak is not None:
            msgs.info("Using tweaked slit boundaries determined from IllumFlat")
            lcen = self.lcen_tweak
            rcen = self.rcen_tweak
        else:
            lcen = self.lcen
            rcen = self.rcen
        # Convert physical traces into a pixel trace
        msgs.info("Converting physical trace locations to nearest pixel")

        # Notice that the slitcen is always defined relative to the untweaked boundaries. This guarantees
        # that the reference location along the slit that we use for wavelength calibration and for tilts is always
        # at a fixed unchanging location.
        self.slitcen = 0.5*(self.lcen+self.rcen)
        self.pixwid = (rcen-lcen).mean(0).astype(np.int)
        self.lordpix = lcen
        self.rordpix = rcen

    def _make_binarr(self):
        """
        Lightly process mstrace

        Returns
        -------
        binarr : ndarray

        """
        #  Only filter in the spectral dimension, not spatial!
        self.binarr = ndimage.uniform_filter(self.mstrace, size=(3, 1), mode='mirror')
        # Step
        self.steps.append(inspect.stack()[0][3])
        return self.binarr


    def _match_edges(self):
        """
        # Assign a number to each edge 'grouping'

        Wrapper to trace_slits.match_edges()

        Returns
        -------
        self.edgearr  : ndarray (internal)
        self.lcnt : int (intenal)
        self.rcnt: int (intenal)

        """

        self.lcnt, self.rcnt = trace_slits.match_edges(self.edgearr, self.ednum)
        # Sanity check (unlikely we will ever hit this)
        if self.lcnt >= self.ednum or self.rcnt >= self.ednum:
            msgs.error("Found more edges than allowed by ednum. Set ednum to a larger number.")
        # Step
        self.steps.append(inspect.stack()[0][3])

    def _maxgap_prep(self):
        """
        First step in the maxgap algorithm
          Likely to be Deprecated

        Returns
        -------
        self.edgearr  : ndarray (internal)
        self.edgearrcp  : ndarray (internal)

        """
        self.edgearrcp = self.edgearr.copy()
        self.edgearr[np.where(self.edgearr < 0)] += 1 + np.max(self.edgearr) - np.min(self.edgearr)
        # Step
        self.steps.append(inspect.stack()[0][3])

    def _maxgap_close(self):
        """
        Handle close edges (as desired by the user)
          JXP does not recommend using this method for multislit

        Wrapper to trace_slits.edgearr_close_slits()

        Returns
        -------
        self.edgearr  : ndarray (internal)

        """
        self.edgearr = trace_slits.edgearr_close_slits(self.binarr, self.edgearr, self.edgearrcp,
                                                        self.ednum, self.par['maxgap'],
                                                        function=self.par['function'],
                                                        polyorder=self.par['polyorder'])
        # Step
        self.steps.append(inspect.stack()[0][3])

    def _mslit_sync(self):
        """
        Synchronize slits in multi-slit mode (ARMLSD)

        Wrapper to trace_slits.edgearr_mslit_sync()

        Returns
        -------
        self.edgearr  : ndarray (internal)
        self.tc_dict  : dict (internal)

        """
        #
        if False:
            self.edgearr = trace_slits.edgearr_mslit_sync(self.edges_dict, self.tc_dict, self.ednum)
        else:
            trace_slits.sync_edges(self.tc_dict, self.mstrace.shape[1])

        # Step
        self.steps.append(inspect.stack()[0][3])

    def _mslit_tcrude(self, maxshift=0.15):
        """
        Trace crude me
          And fuss with slits

        Wrapper to trace_slits.edgearr_tcrude()

        Returns
        -------
        self.edgearr  : ndarray (internal)
        self.tc_dict  : dict (internal)

        """
        # Settings
        _maxshift = self.par['maxshift'] if 'maxshift' in self.par.keys() else maxshift

        # JFH The edgearr looks like we could just pydl fit it and then trace with a crutch as the first step
        # rather than using trace_crude
        self.edgearr, self.tc_dict = trace_slits.edgearr_tcrude(self.edgearr, self.siglev,
                                                                self.ednum, maxshift=_maxshift,
                                                                bpm=self.binbpx)
        # Step
        self.steps.append(inspect.stack()[0][3])

    # ToDO JFH The PCA coefficients take on a wide range of values which makes mad rejection less meaingful. I wonder if we should
    # be doing rejection and fitting using relative errors and relative error deviations.
    def _pca_refine(self, mask_frac_thresh=0.6, coeff_npoly_pca=2, show=False, debug=False):
        """
        Mainly a driver routine to trace_slits.trace_refine() method

        Takes the trace_crude outputs from mslit_tcrude and performs
        a PCA analysis to predict curvature across the detector.

        Slit edges are then found in a rectified, smashed image

        Behavior is distinct for multi-slit vs. echelle

        Args:
            mask_frac_thresh: float, optional
              Fraction of the slit traced by crude which must be 'good' to be included in the first analysis
            coeff_npoly_pca: int, optional
            show: bool, optional

        Returns:
            Fills tc_dict with the 'traces' arrays (in left, right)

        """
        nspec, nspat = self.siglev.shape

        # Fuss with parameters here
        if self.spectrograph.pypeline == 'MultiSlit':
            maxiter = 2
        else:
            maxiter = 3

        # Unpack and sort
        # Left
        slit_left_mean = np.mean(self.tc_dict['left']['xset'],0)
        isort_left = slit_left_mean.argsort()
        slit_left = self.tc_dict['left']['xset'][:, isort_left]
        slit_left_err = self.tc_dict['left']['xerr'][:, isort_left]
        # Right
        slit_righ_mean = np.mean(self.tc_dict['right']['xset'],0)
        isort_righ = slit_righ_mean.argsort()
        slit_righ = self.tc_dict['right']['xset'][:, isort_righ]
        slit_righ_err = self.tc_dict['right']['xerr'][:, isort_righ]

        # Cut on edges
        # Left
        mask_left = (slit_left_err < 900)
        mask_frac_left = np.sum(mask_left, 0) / nspec
        keep_left = mask_frac_left > mask_frac_thresh
        slit_left = slit_left[:, keep_left]
        mask_left = mask_left[:, keep_left]
        # Right
        mask_righ = (slit_righ_err < 900)
        mask_frac_righ = np.sum(mask_righ, 0) / nspec
        keep_righ = mask_frac_righ > mask_frac_thresh
        slit_righ = slit_righ[:, keep_righ]
        mask_righ = mask_righ[:, keep_righ]

        # Do we have enough?
        if np.sum(keep_righ) + np.sum(keep_left) < 5:
            msgs.warn("Less than 5 edges available for the PCA.  Consider lower mask_frac_thresh")

        # Echelle or multi-slit?
        if self.spectrograph.pypeline == 'MultiSlit':
            # Combine left and right slit edges
            slit_in = np.append(slit_left, slit_righ, axis=1)
            mask_in = np.append(mask_left, mask_righ, axis=1)
            # Run it!
            iter = 1
            while iter <= maxiter:
                msgs.info('Doing trace_refine iter#{:d}'.format(iter))
                edges_dict = trace_slits.trace_refine(
                    self.siglev, slit_in, mask_in, npca=None, ncoeff=5,
                    pca_explained_var=99.8, coeff_npoly_pca=coeff_npoly_pca, fwhm=3.0,
                    sigthresh=self.par['sigdetect'], smash_range=self.par['smash_range'],
                    debug=debug)
                # Prep for round 2+
                slit_in = np.append(edges_dict['left']['trace'],
                                    edges_dict['right']['trace'], axis=1)
                mask_in = np.ones_like(slit_in, dtype=bool)
                iter += 1
                # Show
                if show:
                    edges_dict['show'] = 'both'
                    self.show('refined_edges', extras=edges_dict)
        else:
            # Run on left edges
            slit_in = slit_left.copy()
            mask_in = mask_left.copy()
            iter = 1
            while iter <= maxiter:
                msgs.info('Doing trace_refine iter#{:d}'.format(iter))
                trace_dict_l = trace_slits.trace_refine(self.siglev, slit_in, mask_in, npca=None, ncoeff=5,
                                            pca_explained_var=99.8, coeff_npoly_pca=coeff_npoly_pca, fwhm=3.0,
                                            sigthresh=self.par['sigdetect'],
                                                        smash_range=self.par['smash_range'],
                                                        debug=debug, maxrej=1)
                slit_in = trace_dict_l['left']['trace']
                mask_in = np.ones_like(slit_in, dtype=bool)
                iter += 1

                if show:
                    trace_dict_l['show'] = 'left'
                    self.show('refined_edges', extras=trace_dict_l)

            # TODO -- Should sync up left-right in one big while loop after doing one iteration
            # Run on right edges
            iter = 1
            slit_in = slit_righ.copy()
            mask_in = mask_righ.copy()
            while iter <= maxiter:
                msgs.info('Doing trace_refine iter#{:d}'.format(iter))
                trace_dict_r = trace_slits.trace_refine(self.siglev, slit_in, mask_in, npca=None, ncoeff=5, pca_explained_var=99.8,
                                            coeff_npoly_pca=coeff_npoly_pca, fwhm=3.0,
                                            sigthresh=self.par['sigdetect'], debug=debug, maxrej=1)
                slit_in = trace_dict_r['right']['trace']
                mask_in = np.ones_like(slit_in, dtype=bool)
                iter += 1

                if show:
                    trace_dict_r['show'] = 'right'
                    self.show('refined_edges', extras=trace_dict_r)
            # Merge left and right
            edges_dict = {}
            edges_dict['left'] = trace_dict_l['left'].copy()
            edges_dict['right'] = trace_dict_r['right'].copy()

            # A final show
            if show:
                edges_dict['show'] = 'both'
                self.show('refined_edges', extras=edges_dict)

        # Update tc_dict -- we now leave edgearr behind!
        ypos = nspec // 2
        for side in ['left', 'right']:
            xvals = edges_dict[side]['trace'][ypos,:]
            self.tc_dict[side]['xval'] = xvals
            self.tc_dict[side]['traces'] = edges_dict[side]['trace'].copy()
        # Step
        self.steps.append(inspect.stack()[0][3])

    def remove_slit(self, rm_slits, TOL = 3.):
        """
        DEPRECATED

        Remove a user-specified slit

        Wrapper to trace_slits.remove_slit()

        Parameters
        ----------
        rm_slits
          List of slits to remove
            [[left0, right0], [left1, right1]]
          Specified at ycen = nrows//2

        Optional Parameters
        -------------------
        TOL =  tolerance in pixels for grabbing the slit to remove

        Returns
        -------
        self.edgearr  : ndarray (internal)
        self.tc_dict  : dict (internal)
        self.lcen  : ndarray (internal)
        self.rcen  : ndarray (internal)

        """
        self.edgearr, self.lcen, self.rcen, self.tc_dict = trace_slits.remove_slit(
            self.edgearr, self.lcen, self.rcen, self.tc_dict, rm_slits, TOL=TOL)
        # Step
        self.steps.append(inspect.stack()[0][3])

    def rm_user_slits(self, user_slits):
        """
        Remove one or more slits (as applicable)

        Wrapper to trace_slits.rm_user_edges()

        Parameters
        ----------
        user_slits : list

        Returns
        -------
        self.tc_dict is modified in-place

        """
        # Remove user input slits
        trace_slits.rm_user_edges(self.tc_dict, user_slits)
        # Step
        self.steps.append(inspect.stack()[0][3])

    def reset_edgearr_ednum(self):
        """
        Reset the edgearr numbering using self.ednum
          This is needed when one begins from a full run of TraceSlits

        Returns
        -------
        self.edgearr  : ndarray (internal)

        """
        # Were we really final?
        if np.max(self.edgearr) < self.ednum:
            neg = np.where(self.edgearr < 0)
            self.edgearr[neg] -= (self.ednum - 1)
            pos = np.where(self.edgearr > 0)
            self.edgearr[pos] += (self.ednum - 1)

    def _set_lrminx(self, orig=False):
        """
        Set lmin, lmax, etc.

        Returns
        -------
        self.lmin : int (intenal)
        self.lmax: int (intenal)
        self.rmin : int (intenal)
        self.rmax: int (intenal)

        """
        self.lmin, self.lmax = 0, self.lcen.shape[1]
        self.rmin, self.rmax = 0, self.rcen.shape[1]
    #
    # def _synchronize(self):
    #     """
    #     DEPRECATED
    #
    #     Perform final synchronization
    #
    #     Wrapper to trace_slits.synchronize
    #
    #     Returns
    #     -------
    #     Tons and tons..
    #
    #     """
    #     plxbin = self.pixlocn[:, :, 0].copy()
    #     msgs.info("Synchronizing left and right slit traces")
    #     print('ldiff', self.ldiffarr)
    #     print('lwght', self.lwghtarr)
    #     print('lnmbr', self.lnmbrarr)
    #     print('rnmbr', self.rnmbrarr)
    #     print('lcoeff', self.lcoeff)
    #     new = True
    #     if new:
    #         minvf, maxvf = plxbin[0, 0], plxbin[-1, 0]
    #         xv = plxbin[:, 0]
    #         #
    #         self.lcent = utils.func_val(self.lcoeff, xv, self.par['function'], minv=minvf, maxv=maxvf)
    #         self.rcent = utils.func_val(self.rcoeff, xv, self.par['function'], minv=minvf, maxv=maxvf)
    #         # Reset Indexing
    #         self.lnmbrarr += 99999
    #         self.rnmbrarr -= 99999
    #         wl = np.where(self.edgearr < 0)
    #         wr = np.where(self.edgearr > 0)
    #         self.edgearr[wl] += 99999
    #         self.edgearr[wr] -= 99999
    #     else:
    #         self.lcent, self.rcent, self.gord, \
    #             self.lcoeff, self.ldiffarr, self.lnmbrarr, self.lwghtarr, \
    #             self.rcoeff, self.rdiffarr, self.rnmbrarr, self.rwghtarr \
    #                 = trace_slits.synchronize_edges(self.binarr, self.edgearr, plxbin, self.lmin,
    #                                              self.lmax, self.lcoeff, self.rmin, self.rcoeff,
    #                                              self.lnmbrarr, self.ldiffarr, self.lwghtarr,
    #                                              self.rnmbrarr, self.rdiffarr, self.rwghtarr,
    #                                              function=self.par['function'],
    #                                              polyorder=self.par['polyorder'],
    #                                              extrapolate=self.par['pcaextrap'])
    #     print('ldiff', self.ldiffarr)
    #     print('lwght', self.lwghtarr)
    #     print('lnmbr', self.lnmbrarr)
    #     print('rnmbr', self.rnmbrarr)
    #     print('lcoeff', self.lcoeff)
    #     self.slitcen = 0.5*(self.lcent+self.rcent).T
    #     # Step
    #     self.steps.append(inspect.stack()[0][3])

    def _trim_slits(self, trim_slits=True, plate_scale = None, ech_slit_tol = 0.3):
        """
        Trim slits
          Mainly those that fell off the detector
          Or have width less than fracignore

        Args:
            trim_slits: bool, optional
            plate_scale: float, optional
            ech_slit_tol: float, optional

        Returns
        -------
        self.lcen  : ndarray (internal)
        self.rcen  : ndarray (internal)

        """

        # JFH ToDo In principle we could make this trim_slits function a method in the generic spectrograph function, which could then be
        # overloaded by the echelle spectrographs
        nslit = self.lcen.shape[1]
        nspat = self.mstrace.shape[1]
        mask = np.ones(nslit,dtype=bool)

        min_val = np.min(self.lcen,axis=0)
        max_val = np.max(self.rcen,axis=0)

        off_detector = (min_val > nspat) | (max_val < 0)
        mask[off_detector] = False
        # Print out a status message
        ioff = np.where(off_detector)[0]
        for islit in ioff:
            msgs.info('Slit {0:d} is off the detector - ignoring this slit'.format(islit))

        if trim_slits:
            slit_width = np.median((self.rcen - self.lcen) * plate_scale, axis=0)
            if self.spectrograph.pypeline == 'MultiSlit':
                too_short = slit_width < self.par['min_slit_width']
                ishort = np.where(too_short)[0]
                mask[ishort] = False
                for islit in ishort:
                    msgs.info('Slit {0:d}'.format(islit) +
                    ' has width = {:6.3f}'.format(slit_width[islit]) + ' arcseconds < less than min_slit_width = {:} arcseconds'.format(self.par['min_slit_width']) +
                    ' - ignoring this slit')
            elif self.spectrograph.pypeline == 'Echelle':
                # JFH Once we have orders that shrink because of overlap ech_slit_tol will need to be adjusted
                med_width = np.median(slit_width[mask])
                wrong_size = (slit_width > (1.0 + ech_slit_tol)*med_width) | (slit_width < (1.0 - ech_slit_tol)*med_width)
                iwrong = np.where(wrong_size)[0]
                mask[iwrong] = False
                for islit in iwrong:
                    msgs.info('Order {0:d}'.format(islit) +
                    ' has width = {:6.3f}'.format(
                    slit_width[islit]) + ' arcseconds, which is not within ech_slit_tol = {:}%'.format(100.0*ech_slit_tol) +
                    ' of the median order width of {:5.3f}'.format(med_width) + ' arcseconds - ignoring this order')
        # Trim
        self.lcen = self.lcen[:, mask]
        self.rcen = self.rcen[:, mask]
        # Step
        self.steps.append(inspect.stack()[0][3])


    def show(self, attr='edges', pstep=50, extras=None):
        """
        Display an image or spectrum in TraceSlits

        Parameters
        ----------
        attr : str, optional
          'edges' -- Show the mstrace image and the edges
          'binarr' -- Show the binarr image
          'edgearr' -- Show the edgearr image
          'siglev' -- Show the Sobolev image
          'traces' -- Show the traces at an intermediate stage
          'refined_edges' -- Show the traces at an intermediate stage in _pca_refine()
          'xset' -- Check the output from the trace crude
        extras: anything
          Extra bits and pieces needed for plotting
        """
        if attr == 'edges':
            viewer, ch = ginga.show_image(self.mstrace, chname='edges')
            if self.lcen is not None:
                ginga.show_slits(viewer, ch, self.lcen, self.rcen, slit_ids = np.arange(self.lcen.shape[1]) + 1, pstep=pstep)
        elif attr == 'binarr':
            ginga.show_image(self.binarr, chname='binarr')
        elif attr == 'xset':
            viewer, ch = ginga.show_image(self.mstrace, chname='slit_xset')
            color = dict(left='green', right='red')
            viewer, ch = ginga.show_image(self.mstrace)
            for side in ['left', 'right']:
                for kk in range(self.tc_dict[side]['xset'].shape[1]):
                    ginga.show_trace(viewer, ch, self.tc_dict[side]['xset'][:, kk], trc_name=side+ str(kk),color=color[side])
        elif attr == 'refined_edges':
            # Used in _pca_refine()
            edges_dict = extras
            #
            color = dict(left='green', right='red')
            viewer, ch = ginga.show_image(self.mstrace, chname='refined_edges')
            if edges_dict['show'] == 'both':
                for side in ['left', 'right']:
                    for kk in range(edges_dict[side]['nstart']):
                        ginga.show_trace(viewer, ch, edges_dict[side]['trace'][:, kk], trc_name=side + str(kk),
                                         color=color[side])
            else:
                for side in [edges_dict['show']]:
                    for kk in range(edges_dict[side]['nstart']):
                        ginga.show_trace(viewer, ch, edges_dict[side]['trace'][:, kk], trc_name='left_' + str(kk), color=color[side])
        elif attr == 'traces':
            viewer, ch = ginga.show_image(self.mstrace, chname='slit_traces')
            color = dict(left='green', right='red')
            viewer, ch = ginga.show_image(self.mstrace)
            for side in ['left', 'right']:
                for kk in range(self.tc_dict[side]['traces'].shape[1]):
                    ginga.show_trace(viewer, ch, self.tc_dict[side]['traces'][:, kk], trc_name=side+ str(kk),color=color[side], pstep=pstep)
        elif attr == 'edgearr':
            if np.min(self.edgearr) == -1: # Ungrouped
                tmp = self.mstrace.copy()
                # Left edges
                left = self.edgearr == -1
                tmp[left] = -99999.
                # Right edges
                right = self.edgearr == 1
                tmp[right] = 99999.
                viewer, ch = ginga.show_image(tmp, chname='edgearr')
            else: # Grouped
                viewer, ch = ginga.show_image(self.siglev, chname='edgearr')
                # Traces
                all_uni = np.unique(self.edgearr[self.edgearr != 0])
                for uni in all_uni:
                    # Color
                    clr = 'green' if uni < 0 else 'red'
                    # Do it
                    tidx = np.where(self.edgearr == uni)
                    ginga.show_trace(viewer, ch, tidx[1], trc_name=str(uni), yval=tidx[0], color=clr)
        elif attr == 'siglev':
            ginga.show_image(self.siglev, chname='siglev')

    # JFH TODO this needs an argument to follow convention for save_master
    def save_master(self, root=None, gzip=True):
        """
        Write the main pieces of TraceSlits to the hard drive as a MasterFrame
          FITS -- mstrace and other images
          JSON -- steps, settings, ts_dict

        Parameters
        ----------
        root : str (Optional)
          Path+root name for the output files
        gzip : bool (optional) JFH TURNED OFF GZIPPING
          gzip the FITS file (note astropy's method for this is *way* too slow)
        """
        if root is None:
            root = self.ms_name
        # Images
        outfile = root+'.fits'
        hdu = fits.PrimaryHDU(self.mstrace.astype(np.float32))
        hdu.name = 'MSTRACE'
        hdu.header['FRAMETYP'] = 'trace'
        hdulist = [hdu]
        if self.edgearr is not None:
            hdue = fits.ImageHDU(self.edgearr)
            hdue.name = 'EDGEARR'
            hdulist.append(hdue)
        if self.siglev is not None:
            hdus = fits.ImageHDU(self.siglev.astype(np.float32))
            hdus.name = 'SIGLEV'
            hdulist.append(hdus)
        # PIXLOCN -- may be Deprecated.
        #hdup = fits.ImageHDU(self.pixlocn.astype(np.float32))
        #hdup.name = 'PIXLOCN'
        #hdulist.append(hdup)
        if self.input_binbpx:  # User inputted
            hdub = fits.ImageHDU(self.binbpx.astype(np.int))
            hdub.name = 'BINBPX'
            hdulist.append(hdub)
        if self.lcen is not None:
            hdulf = fits.ImageHDU(self.lcen)
            hdulf.name = 'LCEN'
            hdulist.append(hdulf)
            hdurt = fits.ImageHDU(self.rcen)
            hdurt.name = 'RCEN'
            hdulist.append(hdurt)
        if self.slitcen is not None:
            hdulf = fits.ImageHDU(self.slitcen)
            hdulf.name = 'SLITCEN'
            hdulist.append(hdulf)
        if self.lcen_tweak is not None:
            hdulf = fits.ImageHDU(self.lcen_tweak)
            hdulf.name = 'LCEN_TWEAK'
            hdulist.append(hdulf)
            hdurt = fits.ImageHDU(self.rcen_tweak)
            hdurt.name = 'RCEN_TWEAK'
            hdulist.append(hdurt)

        # Write
        hdul = fits.HDUList(hdulist)
        hdul.writeto(outfile, overwrite=True)
        msgs.info("Wrote TraceSlit arrays to {:s}".format(outfile))
        # TODO None of our other masters are compressed so why do we gzip these?
        if gzip:
            msgs.info("gzip compressing {:s}".format(outfile))
            command = ['gzip', '-f', outfile]
            Popen(command)

        # dict of steps, settings and more
        out_dict = {}
        # JFH added this below because of a crash discovered when running save_master from a pre-existing MasterFile
        if isinstance(self.par, pypeitpar.TraceSlitsPar):
            out_dict['settings'] = parset_to_dict(self.par)
        elif isinstance(self.par, dict):
            out_dict['settings'] = self.par
        else:
            msgs.error('Unrecognized type for self.par')
        if self.tc_dict is not None:
            out_dict['tc_dict'] = self.tc_dict
        out_dict['steps'] = self.steps
        out_dict['spectrograph'] = self.spectrograph.spectrograph
        binspatial, binspectral = parse.parse_binning(self.binning)
        binning = parse.binning2string(binspatial, binspectral)
        out_dict['binning'] = binning
        # Clean+Write
        outfile = root+'.json'
        clean_dict = ltu.jsonify(out_dict)
        ltu.savejson(outfile, clean_dict, overwrite=True, easy_to_read=True)
        msgs.info("Writing TraceSlit dict to {:s}".format(outfile))

    def load_master(self, filename, force = False):
        """
        Load the master frames

        Args:
            filename: str
            force: bool, optional

        Returns:
            answer: bool

        """
        # Does the master file exist?
        if not (os.path.isfile(filename + '.fits.gz') & os.path.isfile(filename + '.json')):
            msgs.warn("No Master frame found of type {:s}: {:s}".format(self.frametype, filename))
            return None
        else:
            # Load from filename extension. There is a fits and json file, and this routine also does file checking
            fits_dict, ts_dict = load_traceslit_files(filename)
            # Fail?
            if fits_dict is None:
                return False
            # Load up self
            self.binbpx = fits_dict['BINBPX'].astype(float)  # Special
            for key in ['MSTRACE', 'PIXLOCN', 'LCEN', 'RCEN', 'SLITCEN', 'LCEN_TWEAK', 'RCEN_TWEAK', 'EDGEARR', 'SIGLEV']:
                if key in fits_dict.keys():
                    setattr(self, key.lower(), fits_dict[key])
            # Remake the binarr
            self.binarr = self._make_binarr()
            # dict
            self.tc_dict = ts_dict['tc_dict']

            self.spectrograph = util.load_spectrograph(ts_dict['spectrograph'])
            # Set some paramaeters so that the fill_tslits_dict routine will work.
            self.par = ts_dict['settings']
            self.binning = ts_dict['binning']
            # Fill
            self._fill_tslits_dict()
            # Success
            return self.tslits_dict

#    def master_old(self):
#        """ Mainly for PyepIt running
#
#        Parameters
#        ----------
#
#        Returns
#        -------
#        loaded : bool
#
#        """
#        # Load master frame?
#        loaded = False
#        if self._masters_load_chk():
#            loaded = self.load_master()
#        # Return
#        return loaded

    def run(self, add_user_slits=None, rm_user_slits=None, trim_slits=True,
            plate_scale=None, show=False, write_qa=True, debug=False):
        """ Main driver for tracing slits.

          Code flow
           1.  Determine approximate slit edges (left, right)
             1b.    Trim down to one pixel per edge per row [seems wasteful, but ok]
           2.  Give edges ID numbers + stitch together partial edges (match_edges)
             2b.   first maxgap option -- NOT recommended
           3.  Assign slits (left, right) ::  Deep algorithm
           4.  For ARMLSD
              -- Trace crude the edges
              -- Do a multi-slit sync to pair up left/right edges
           5.  Remove short slits -- Not recommended for ARMLSD
           6.  Fit left/right slits
           7.  Synchronize
           8.  Extrapolate into blank regions (PCA)
           9.  Perform pixel-level calculations
           10. Make the QA plot

        Parameters
        ----------
        ignore_orders : bool (optional)
          Perform ignore_orders algorithm (recommended only for echelle data)
        add_user_slits : list of lists
          List of 3 element lists, each an [xleft, xright, yrow] specifying a slit edge
          at a given yrow
        rm_user_slits : list of lists
          List of 2 element lists, each an [xcen, yrow] specifying a slit center.  Any
          slit containing it will be removed

        Returns
        -------
        tslits_dict : dict or None (if no slits)
          'lcen'
          'rcen'
          'slitcen'
          'pixwid'
          'lordpix'
          'rordpix'
          'extrapord'
          'slitpix'
        """
        # Generate binarr
        _ = self._make_binarr()

        # Specify a single slit?
        if len(self.par['single']) > 0:  # Single slit
            self._edgearr_single_slit()
            self.user_set = True
        else:  # Generate the edgearr from the input trace image
            self._edgearr_from_binarr()
            self.user_set = False

        # Assign a number to each edge 'grouping'
        self._match_edges()

        # Add in a *single* left/right edge?
        #  Mainly useful for longslit where one or both sides butt up on the edge of the detector
        any_slits = self._add_left_right()
        if not any_slits:
            return None

        # Final left/right edgearr fussing (as needed)
        #  Mainly useful for longslit
        if not self.user_set:
            self._final_left_right()

        # Trace crude in siglev image and sync traces
        self._mslit_tcrude()


        # Are we done, e.g. a simple longslit?
        #   Check if no further work is needed (i.e. there only exists one order)
        if self._chk_for_longslit():
            pass
        else:  # No, not done yet
            # Refine
            self._pca_refine(mask_frac_thresh=self.par['mask_frac_thresh'], debug=debug, show=show)
            # Synchronize and add in edges
            self._mslit_sync()
            # Add user input slits
            if add_user_slits is not None:
                self.add_user_slits(add_user_slits)
            # Remove user input slits
            if rm_user_slits is not None:
                self.rm_user_slits(rm_user_slits)

        # Set lcen and rcen, lmin, lmax
        self.lcen = self.tc_dict['left']['traces']
        self.rcen = self.tc_dict['right']['traces']
        self._set_lrminx()
        self.extrapord = np.zeros(self.lcen.shape[1], dtype=np.bool)

        # Remove any slits that are completely off the detector
        #   Also remove short slits here for multi-slit and long-slit (alignment stars)
        #if self.nslit > 1:
        self._trim_slits(trim_slits=trim_slits, plate_scale=plate_scale)

        # Adjust slit edges
        self.lcen += self.par['trim'][0]
        self.rcen -= self.par['trim'][1]

        # Generate pixel arrays
        self._make_pixel_arrays()

        # fill dict for PypeIt
        self.tslits_dict = self._fill_tslits_dict()

        # Make the QA
        if write_qa:
            self._qa()

        # Return it
        return self.tslits_dict

    def _qa(self, use_slitid=True):
        """
        QA
          Wrapper to trace_slits.slit_trace_qa()

        Returns
        -------

        """
        slitmask = pixels.tslits2mask(self.tslits_dict)
        trace_slits.slit_trace_qa(self.mstrace, self.lcen,
                                   self.rcen, slitmask, self.extrapord, self.master_key,
                                   desc="Trace of the slit edges D{:02d}".format(self.det),
                                   use_slitid=use_slitid, out_dir=self.redux_path)


    def __repr__(self):
        # Generate sets string
        txt = '<{:s}: '.format(self.__class__.__name__)
        if len(self.steps) > 0:
            txt+= ' steps: ['
            for step in self.steps:
                txt += '{:s}, '.format(step)
            txt = txt[:-2]+']'  # Trim the trailing comma
        txt += '>'
        return txt


def load_traceslit_files(root):
    """
    Load up the TraceSlit objects from the FITS and JSON file

    Pushed out of the class so we can both load and instantiate
    from the output files

    Parameters
    ----------
    root : str

    Returns
    -------
    fits_dict : dict
      Contains all the images from the FITS file
    ts_dict : dict
      JSON read
    """
    fits_dict = {}
    # Open FITS
    fits_file = root+'.fits.gz'
    if not os.path.isfile(fits_file):
        msgs.error("No TraceSlits FITS file found!")

    msgs.info("Loading a pre-existing master calibration frame of type: trace from filename: {:}".format(fits_file))
    hdul = fits.open(fits_file)
    names = [ihdul.name for ihdul in hdul]
    if 'SLITPIXELS' in names:
        msgs.error("This is an out-of-date MasterTrace flat.  You will need to make a new one")

    # Load me
    for key in ['MSTRACE', 'PIXLOCN', 'BINBPX', 'LCEN', 'RCEN', 'LCEN_TWEAK', 'RCEN_TWEAK', 'SLITCEN', 'EDGEARR', 'SIGLEV']:
        if key in names:
            fits_dict[key] = hdul[names.index(key)].data

    # JSON
    json_file = root+'.json'
    ts_dict = ltu.loadjson(json_file)

    # Recast lists to ndarray
    for side in ['left', 'right']:
        for key in ['xset', 'traces']:
            ts_dict['tc_dict'][side][key] = np.array(ts_dict['tc_dict'][side][key])

    # Return
    return fits_dict, ts_dict



def load_tslits_dict(filename):
    """
    Utility function which enables one to load the tslits_dict from a master file in one line of code without
    instantiating the class.

    Parameters
    ----------
    filename: str
       Master file name
           slit : int, optional

    Returns
    -------
    Fills:
      wv_calib
        wv_calib dict
      par
        parset
    """


    traceSlits = TraceSlits(None,None)
    return traceSlits.load_master(filename)